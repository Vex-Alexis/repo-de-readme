# üì¶ Sistema de Gesti√≥n de Inventario

Sistema de gesti√≥n de inventario basado en **microservicios**, desarrollado en **Java 21** con **Spring Boot 3.5.3**.  
Permite registrar productos, consultar su inventario y registrar movimientos de stock

<br> <!-- Salto de l√≠nea -->
## Contenido



- [Funcionalidades Principales](#-funcionalidades-principales)
- [Tecnolog√≠as Utilizadas](#%EF%B8%8F-tecnolog√≠as-utilizadas)
- [Instalaci√≥n y ejecuci√≥n](#-instalaci√≥n-y-ejecuci√≥n)
- [Descripci√≥n de la arquitectura y patrones de dise√±o](#%EF%B8%8F-descripci√≥n-de-la-arquitectura-y-patrones)
- [Diagrama de interacci√≥n entre servicios](#-diagrama-de-interacci√≥n-entre-servicios)
- [Decisiones t√©cnicas y justificaciones](#%EF%B8%8F-decisiones-t√©cnicas-y-justificaciones)
- [Explicaci√≥n del flujo de compra implementado](#-explicaci√≥n-del-flujo-de-compra-implementado)
- [Endpoints](#-endpoints)
- [Documentaci√≥n de endpoints](#-documentaci√≥n-de-endpoints)
- [Manejo de Excepciones](#-manejo-de-excepciones)
- [Pruebas](#-pruebas)
- [Documentaci√≥n sobre el uso de herramientas de IA](#-documentaci√≥n-sobre-el-uso-de-herramientas-de-ia)




<br> <!-- Salto de l√≠nea -->
## üß© Funcionalidades Principales

- Crear producto, consultar por ID y obtener lista de productos
- Consultar stock de producto y obtener su informacion desde el otro microservicio
- Actualizar cantidad disponible de producto
- Endpoint de movimientos (para integrar flujo de compras o transacciones)
- Comunicacion sincronica entre microservicios mediante HTTP
- Arquitectura limpia y patrones de dise√±o
- Se implementa transaccion para mantener la consistencia de datos entre ambos servicios (atomicidad)
- Manejo de exepciones, se implementan personalizadas y se crean un manejador global de excepciones
- Respuestas del API cumpliendo los estandares de JSON:API
- Autenticacion basica mediante API keys
- Manejo de timeouts y reintentos basicos con circuit braker
  



<br> <!-- Salto de l√≠nea -->
## üõ†Ô∏è Tecnolog√≠as Utilizadas
- Java 21
- Spring Boot 3.5.3
- Spring WebFlux (WebClient)
- PostgreSQL
- Resilience4j (Circuit Breaker)
- Docker & Docker Compose
- Maven


<br> <!-- Salto de l√≠nea -->
## üì¶ Instalaci√≥n y ejecuci√≥n

1. Clona el repositorio:
```bash
git clone https://github.com/Vex-Alexis/devsu-sistema-bancario.git
```
2. Navega al directorio del proyecto:
```bash
cd devsu-sistema-bancario
```
3. Levanta los servicios:
```bash
docker-compose up -d
```
4. Servicios expuestos:

| Servicio                | Puerto
|-------------------------|------
| product-service         | `8080`
| inventory-service       | `8081`
| product-db              | `5433`
| inventory-db            | `5434`

> Aseg√∫rate de que no est√©n siendo usados por otros procesos.


<br> <!-- Salto de l√≠nea -->
## üèõÔ∏è Descripci√≥n de la arquitectura y patrones

El proyecto est√° implementado una **Arquitectura limpia** con el patr√≥n **Ports & Adapters (arquitectura hexagonal)** y aplicando principios de **DDD (Domain-Driven Design)** para una mejor separaci√≥n de responsabilidades y mantenibilidad. Cada capa tiene su responsabilidad: 

<p align="center">
  <img src="estructura-microservicio.png" alt="Arquitectura general" width="400"/>
</p>

 #### - Domain
Contiene los modelos y entidades de dominio, que representan las reglas y la l√≥gica de negocio Tambi√©n define los puertos como interfaces ("Gateways") que se utilizar√°n en la capa de negocio.
 #### - Business
Define la l√≥gica de la aplicaci√≥n y reacciona a las invocaciones de los `entry-poits`, orquestando los flujos y utilizando los puertos definidos.
 #### - Infraestructure
En esta capa, se detallar√°n las tecnolog√≠as e implementaciones de los puertos definidos en la capa de dominio. Esta capa est√° compuesta por dos grupos de m√≥dulos llamados `entry-points` y `driven-adapters`.
  - `driven-adapters` son los m√≥dulos implementan las interfaces ("Gateways") para conectar tecnolog√≠as externas al sistema, como conexiones a bases de datos, servicios REST, SOAP, lectura de archivos planos y, en particular, cualquier fuente de datos con la que debamos interactuar.
  - `entry-poits` son los puntos de entrada de la aplicaci√≥n o el inicio de los flujos de negocio. Estos pueden ser controladores REST, consumidores de Kafka, SQS, etc, adem√°s de manejo centralizado de excepciones.

## ‚úèÔ∏è patrones de dise√±o

- **Dependency Injection:** facilita la inversi√≥n de dependencias y el desac acoplamiento de componentes.
- **Repository Pattern:** abstrae el acceso a la persistencia, ocultando detalles del almacenamiento.
- **Adapter Pattern:** permite integrar tecnolog√≠as o servicios externos sin acoplar el dominio.
- **Service Layer:** encapsula la l√≥gica de negocio de la aplicaci√≥n.
- **Transactional:** asegura la integridad de los datos durante operaciones cr√≠ticas.
- **DTO & Mapper:** se usan para transferir datos entre capas y evitar exponer directamente las entidades de dominio.
- **Resilience Patterns:** implementaci√≥n de reintentos, timeouts u otros mecanismos para mayor tolerancia a fallos.
- **Exception Handler:** manejo centralizado de errores para devolver respuestas consistentes.



<br> <!-- Salto de l√≠nea -->
## üîÑ Diagrama de interacci√≥n entre servicios


<p align="center">
  <img src="diagrama-interaccion-microservicios.png" alt="Interaccion microservicios" width="600"/>
</p>


El sistema implementa una arquitectura de microservicios donde cada servicio tiene su propia base de datos (Database per Service) y se comunica de la siguiente forma:

- Comunicaci√≥n s√≠ncrona:
`inventory-service` consume el API REST de `product-service` mediante WebClient, para obtener la informaci√≥n del producto.
Para garantizar resiliencia se implementa un circuit breaker que maneja reintentos, fallback y timeout, evitando que fallas en `product-service` afecten a `inventory-service`.

- Comunicaci√≥n as√≠ncrona (Planeado, no implementado):
La idea era que `product-service` publicara un evento a AWS SQS al crear un nuevo producto, y `inventory-service` consumiera ese evento para crear autom√°ticamente el inventario correspondiente.
Esto permitir√≠a desacoplar los servicios y procesar eventos de forma eventual.


<br> <!-- Salto de l√≠nea -->
## ‚öôÔ∏è Decisiones t√©cnicas y justificaciones

- **Base de datos (PostgreSQL por microservicio):** Se eligi√≥ PostgreSQL por ser una base de datos relacional robusta, ampliamente adoptada, con soporte avanzado para integridad referencial y transacciones. Adem√°s, cada microservicio tiene su propia base de datos (Database per Service) para garantizar un mayor desacoplamiento, escalabilidad y evitar dependencias directas a nivel de datos entre servicios.
- **Comunicaci√≥n s√≠ncrona usando WebClient:** Se opt√≥ por una llamada HTTP REST s√≠ncrona entre `inventory-service` y `product-service` para resolver solicitudes en tiempo real (en este caso, consultar informaci√≥n actualizada del producto). Se eligi√≥ WebClient por su naturaleza reactiva, ligera y no bloqueante, mejorando el rendimiento y escalabilidad
- **Registros at√≥micos y manejo transaccional:** Al registrar un movimiento de inventario (compra o venta) y actualizar el stock, se configur√≥ la operaci√≥n como transaccional. Esto asegura que las operaciones se realicen de forma at√≥mica, manteniendo la consistencia de los datos incluso ante fallos parciales

- **Manejador global de excepciones:** Se cre√≥ un handler global que captura errores controlados y lanza respuestas claras al cliente. Sse definieron excepciones personalizadas que son lanzadas desde la l√≥gica de negocio ante casos esperados (como no existencia de un producto, datos inv√°lidos, etc.), permitiendo separar la gesti√≥n de errores de la l√≥gica principal.


### Flujo de compra (justificaci√≥n de no implementarlo):
Se consider√≥ que un flujo de compra completo corresponder√≠a a un microservicio dedicado de √≥rdenes o compras, siguiendo el principio de responsabilidad √∫nica y evitando un alto acoplamiento.
En lugar de esto, se implement√≥ en `inventory-service` un **flujo de movimientos** (SALE o PURCHASE) que permite registrar salidas o ingresos de stock. La petici√≥n recibe el ID del producto, la cantidad y el tipo de movimiento; en el caso de venta se descuenta del stock y en compra se suma, validando siempre que los valores sean positivos.
- **Circuit breaker (Resilience4j):** Se implement√≥ un circuit breaker usando Resilience4j para proteger el `inventory-service` de fallas o latencias excesivas al consumir el `product-service`. Este patr√≥n gestiona reintentos, fallback y timeout, evitando fallos en cascada y mejorando la resiliencia general del sistema.





<br> <!-- Salto de l√≠nea -->
## üõí Explicaci√≥n del flujo de compra implementado

<br> <!-- Salto de l√≠nea -->
## üì° Endpoints

<br> <!-- Salto de l√≠nea -->
## üìÑ Documentaci√≥n de endpoints

<br> <!-- Salto de l√≠nea -->
## üö® Manejo de Excepciones

<br> <!-- Salto de l√≠nea -->
## üß™ Pruebas

- Test Containers Prueba unitarias y de integracion

<br> <!-- Salto de l√≠nea -->
## ü§ñ Documentaci√≥n sobre el uso de herramientas de IA






